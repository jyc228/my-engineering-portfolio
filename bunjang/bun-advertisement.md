# 데이터 기반 최적화를 통한 광고 비즈니스 성장 주도

## 배경 & 도전

다른 업무를 수행하던 중, 외부 광고 API 서버에서 약 20%의 광고 지면이 채워지지 못해 발생하는 기회비용을 포착했고, 이를 수익화하는 프로젝트를 자발적으로 기획하여 팀에 제안했습니다.

이후 외부 광고 제공 서버 담당 동료 개발자와 우스갯소리처럼 시작했지만, **광고 미송출 비율 5% 미만, 일 추가 수익 100만원**이라는 OKR의 정신에 입각한 도전적인 목표를 자체적으로 수립했습니다.
이 목표를 나침반 삼아 개선 작업을 주도했습니다.

저의 역할은 문제의 근본 원인을 진단하고, 개선 전략을 수립하며, 기술 방향 제시 및 코드 리뷰를 통해 동료의 성장을 돕고 팀의 성과를 함께 만들어가는 것이었습니다. 실제 구현은 동료 개발자가 담당했습니다.

## 프로젝트 개요

- 기간: 2025.4 - 2025.6 (약 2개월)
- 인원: 백엔드 2명
- 핵심 기술: Kotlin, Kotlin Coroutine, Spring Webflux
- 주요 역할: 구조 설계 및 코드 리뷰

## 주요 해결 과제

처음부터 미송출 광고를 개선하려고 시작했던건 아니었습니다. 1단계, 2단계 개선을 하면서 빈 지면이 20%정도 된다라는 사실을 알게 되었고, 이를 해결하기 위해 다각도로 키워드를 가공하여 검색어와 유사한 광고 상품을
보여줄 수 있도록 개선했습니다.

### 1단계: 구조 개선 (기반 다지기)

가장 먼저 최적화를 진행할 수 있는 안정적인 코드 기반을 마련했습니다.

- 코드 리팩토링: 도메인, 기능, 비기능 코드로 레이어를 명확히 분리하여 코드의 가독성과 유지보수성을 확보했습니다.
- 호출 구조 변경: 직렬 처리 방식에서 병렬, 경쟁 기반의 광고 호출 구조로 변경하여 응답 시간의 기반을 개선했습니다.

**before**

```kotlin
suspend fun getAds() {
    // 조회 실패시 기존 요청을 취소하고 후순위 광고 조회 시도합니다.
    // 전체 타임아웃이 존재합니다. (약 2초)
    for (provider in adProviders) {
        try {
            // 구현체에서 webclient 를 사용중이며 timeout 350ms 적용되어 있음
            return provider.fetchAds()
        } catch (e: Throwable) {
        }
    }
    return null
}
```

**after**

```kotlin
suspend fun getAds() {
    // 일정 간격으로 후수위 광고를 조회 하며 (폭포수 미디에이션), 기존 호출을 취소하지 않고 먼저 도착한 광고를 응답합니다.
    // 전체 타임아웃이 존재합니다. (약 2초)
    val resultChannel = Channel()
    val requestJob = launch {
        for (provider in adProviders) {
            val job = launch {
                try {
                    resultChannel.send(provider.fetchAds())
                } catch (e: Throwable) {
                }
            }
            // 선순위 광고사의 광고가 먼저 나갈 수 있도록 요청 완료까지 일정 시간 대기 합니다.
            withTimeoutOrNull(provider.timeout) { job.join() }
        }
    }
    return select {
        resultChannel.onReceive { it }
        requestJob.onJoin { null } // 모든 광고 제공자들로부터 광고 조회 실패
    }.also { resultChannel.close(); requestJob.close() }
}
```

### 2단계: 비효율 제거 (성능 최적화)

불필요한 네트워크 호출을 제거하여 즉각적인 성능 향상과 비용 절감을 달성했습니다.

- 실패 이력 캐싱: 외부 API에서 광고가 없는 것으로 확인된 키워드는 Redis에 저장하여, 동일한 요청에 대해 더 이상 불필요한 API를 호출하지 않도록 했습니다.
- 페이지네이션 정보 캐싱: 키워드별 광고 총 개수를 Redis에 저장하여, offset 파라메터를 최적화 했습니다.

### 3단계: 가치 창출 (광고 요청 성공률 극대화)

가장 핵심적인 부분으로, 광고가 없는 키워드를 재가공하여 새로운 광고를 찾아내는 전략을 구현했습니다.
이는 가장 비용이 적고 확률이 높은 방법부터 점진적으로 시도하도록 설계되었습니다.

- 핵심 단어 추출: 사용자의 검색어에서 공백을 기준으로 단어를 분리하고, 가장 긴 핵심 단어를 추출하여 다시 광고를 요청했습니다.
- 성공 이력 기반 재탐색: 위에서 추출된 키워드들을 전날 광고가 성공적으로 송출되었던 키워드 풀에서 재탐색하여 성공률을 높였습니다.
- 오타 교정 및 연관 검색 확장 (향후 계획): 자동 완성 API를 활용한 오타 교정, 연관 검색어 API를 통한 키워드 확장 등 추가적인 전략을 계획하고 3차, 4차 배포를 준비하고 있습니다.

## 성과 및 임팩트

이러한 점진적인 개선은 측정 가능한 비즈니스 성과로 즉시 이어졌습니다.

### 1단계: 구조 개선

순차식 광고 호출에서 병렬 / 경쟁 기반으로 개선되면서 우선순위가 높은 광고사의 광고가 나갈 확률이 높아졌습니다.

### 2단계: 비효율 제거

- 광고가 없는 키워드의 광고 요청을 막으면서 https 요청량이 10% 이상 줄어들었습니다.
- 페이지네이션 최적화를 통해, jvm 힙 사이즈가 5~10% 정도 줄어들었습니다.

### 3단계: 가치 창출

- 1차 배포: 광고 미송출 비율 20% → 18% 감소, 일 추가 수익 약 30만 원 발생
- 2차 배포: 광고 미송출 비율 18% → 15% 감소, 일 추가 수익 약 50만 원으로 증대
- 최종 목표: 미송출 비율 5% 미만 달성 및 일 추가 수익 100만 원 확보

이 프로젝트를 통해 저는 기술적 문제 해결을 넘어, 비즈니스 지표를 직접 개선하고 동료의 성장을 도우며 팀의 성과를 함께 만들어가는 리더십과 멘토링 역량을 증명했습니다.